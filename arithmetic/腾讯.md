# this 闭包 作用域问题
```js
var num = 10
const obj = {num: 20}

obj.fn = (function (num) {
  this.num = num * 3
  num++
  return function (n) {
    this.num += n
    num++
    console.log(num)
  }
})(obj.num)

var fn = obj.fn

fn(5)
obj.fn(10)
console.log(num, obj.num)
```

# 继承
```js
class A {}
实例a.__proto__ 、a.__proto__.__proto__、a.__proto__.__proto__.__proto__

Function.__proto__ == Function.prototype
```


# 异步，eventloop
```js
var promiseA = new Promise(function(resolved) {
    setTimeout(function() {
      console.log('p1')
      resolved('p1 resolved');
    }, 0);
  
    console.log('p0');
    resolved('p0 resolved');
    var promise2 = new Promise((resolved2) => {
      console.log('p2');
      resolved2('p2 resolved');
    });
    promise2.then((msg) => {
      console.log(msg);
    });
  })
  
  console.log('start');
  promiseA.then((msg) => {
   console.log(msg)
  });

  
  //p0 ,p2 ,start,  p2 resolved, p0 resolved  p1
```

# 1. 实现一个reducer
[10,20,30].reducer((a,b)=>a+b, 0) // 60

# 2. 有效的括号
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。
有效字符串需满足：
（1）左括号必须用相同类型的右括号闭合。
（2）左括号必须以正确的顺序闭合。
注意：空字符串可被认为是有效字符串。

示例1："()" // true
示例2："()[]{}" // true
示例3："(]" // false
示例4："([)]" //  false
示例5："{[]}" // true


```js
s = "[(())]"

function test(s) {
    a = s.split("")
    m = {")":"(", "]":"[", "}":"{"}
    b = []
    
    for(var i = 0; i < a.length; i++) {
        let item = a[i];
        let c;
        if(item === '(' || item === '[' || item === '{') {
            b.push(item)
        } else {
            c = b.pop()
            if (m[item] != c) {
                return false;
            }
        }
    }
    
    if(b.length !== 0) {
        return false;
    }
    
    return true;
}
console.log(test(s))
```


# 3. 大数相加
给定两个字符串形式的非负整数 num1 和 num2, 计算它们的和；
提示：
1. num1 和 num2 都只包含数字 0-9
2. num1 和 num2 都不包含任何前导零
3. 两个数都是以字符串的方式提供
示例1：
function addBigInt(str1, str2) {
}
var a ='123456789123456789';
var b = '23456789123456789';
console.log(addBigInt(a, b));
//'146913578246913578'

```js
function addBigInt(str1, str2) {
	let arr1 = str1.split('').reverse(),
		arr2 = str2.split('').reverse(),
		i = 0,
		pre = 0,
		res = []

		while(i < arr1.length || i < arr2.length) {
			let a1 = arr1[i] ? Number(arr1[i]) : 0,
				a2 = arr2[i] ? Number(arr2[i]) : 0
			let target = a1 + a2 + pre
			target = target > 9 ? target - 10 : target
			res.unshift(target)
			pre = (a1 + a2 + pre) > 9 ? 1 : 0
			i++
		}

		return res.join('')
}
var a ='123456789123456789';
var b = '23456789123456789';
console.log(addBigInt(a, b))




	function addBigInt(str1, str2) {
		let arr1 = str1.split(''),
			arr2 = str2.split(''),
			i = arr1.length - 1,
			j = arr2.length - 1,
			res = [],
			pre = 0

		while (i >= 0 || j >= 0) {
			let target = 0
			if (i >= 0) {
				target = target + Number(arr1[i])
				i--
			}
			if (j >= 0) {
				target = target + Number(arr2[j])
				j--
			}
			target = target + pre
			if (target > 9) {
				target = target - 10
				pre = 1
			} else {
				pre = 0
			}
			res.unshift(target)
		}

		if (pre > 0) {
			res.unshift(pre)
		}

		return res.join('')
	}

	var a = '123456789123456789';
	var b = '23456789123456789';
	console.log(addBigInt(a, b))
```

# 4. 求数组中两个元素相加为某个值的两个坐标（要求O(n)复杂度）
```JS
getTargetIndexs([3,4,5,7,9], 10)

function getTargetIndexs(arr, sum) {
    let obj = {};
    let res;
    let arr1 = []
    arr.forEach((item, i) => {
        res = sum - item
        if(obj[res] !== undefined) {
            arr1.push([obj[res], i])
        }

        obj[item] = i;
    })
    console.log(arr1)
}

// 自实现：
var twoSum = function(numbers, target) {
    let obj = {}
    let res = []
    for (var i = 0; i < numbers.length; i++) {
        if (obj[target - numbers[i]] !== undefined) {
            res.push([obj[target - numbers[i]], i + 1])
        }
        obj[numbers[i]] = i + 1
    }

    return res[0]
};
```

# less: 函数调用，传参， 颜色， 计算， 倒入， 嵌套

# BFC

# webpack

# 居中

# flex

# http1.0 http2.0 http3.0 https

# redux

# 虚拟dom

# 浏览器渲染 even loop