一颗二叉树打遍所有核心算法思想
广度优先
层序遍历
应用：求最小高度，fiber架构的siblings指针，左视图，右视图等
增加两个叉，四叉树（上下左右）就是二维数组，应用：最短路径，岛屿沉默问题，图算法（图可以用二维数组存储）
有向图
无向图（双向图），优化方案
备忘录，记录已访问过的节点
双向遍历，初始节点-> 目标节点，目标节点 -> 初始节点
双向遍历的时候，每一步从初始节点和目标节点里，选择节点数少的那一层进行遍历，最终能通过最少的节点遍历得到结果，这就贪心算法的核心思想，通过局部最优得到全局最优
深度优先
前序
fiber架构的siblings指针
核心思想：先处理当前节点，再处理子节点，快排(平均nlogn，最差n²)，chrome对sort函数的实现，10以内插入排序(稳定排序算法)，10以上快排（不稳定排序算法），因为空间复杂度O(1) ，火狐是合并排序
动态规划从上往下的递归遍历(比如斐波那契数列)
核心思想：穷举，通常用于求最值
优化方案：状态存储，如果某个状态值被多次使用，或者有多条路径到达，就需要进行状态存储，减少计算
增加N个叉，N叉树，回溯算法
核心思想：穷举，通常用于求组合，排列，N皇后等
优化方案：剪枝
后序
核心思想：当前节点的处理逻辑，需要依赖子节点的状态，比如合并排序(nlogn)，求最大深度
后序遍历的递归函数的实现思路
思维不要进入递归里面，我们的大脑压不了那么多栈，而是要相信你的函数的返回值，把注意力关注在当前节点的处理逻辑上，比如合并排序，我们通常取中间节点，然后把数组拆分为两个子数组，递归处理这两个子数组，我们的函数的最终返回值是排序数组，所以就相信递归处理后的两个子数组的返回值就是排序数组，所以我们当前要做的就是把这两个排序数组合并成一个排序树组并返回，问题就解决了
再比如二叉树的最大深度，我们函数的返回值是以当前节点为根节点的二叉树最大深度，递归拿到左子树的最大深度，再递归拿到右子树的最大深度，然后我们关注的当前节点的最大深度就是左右子树的最大值加1
动态规划从下往上的迭代遍历
优化方案：状态压缩，降低空间复杂度，比如当前状态如果只依赖前一个或者前几个状态，就可以只存储这几个状态
中序
二叉搜索树
排序数组
数组：双指针的左右指针，滑动窗口，单调栈(接雨水)，求子数组，子序列，滑动窗口的最大值等
二叉搜索树的查值
就是二分法
堆（小顶堆，大顶堆）
TopN
优先级队列（应用：React的事件调度）
队列：栈实现队列，队列实现栈
栈的应用：有效括号
减少一个叉
链表
单链表：双指针的快慢指针，链表的反转，合并，删除，找中间节点，判断环以及入环的节点
增加prev指针，双向链表：React的faber架构（return指针，和child指针）